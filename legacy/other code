
const majorClassDependenciesGraph = async () => {

};

const callMiddlewareAPI = async () => {
    try {
      const response = await fetch('http://localhost:5001/sample');
      const data = await response.text();

      const dagData = data;
      setDag(dagData);
    } catch (error) {
      console.error('Error fetching major graphviz data:', error);
    }
  };

<button onClick={callMiddlewareAPI}>Call Middleware API</button>
{message && (
  <div>
    <p>{message}</p>
    <textarea
      rows={4}
      cols={50}
      value={responseText}
      onChange={handleResponseChange}
      readOnly
    />
  </div>
)}

<textarea value={dag} onChange={(e) => setDag(e.target.value)}></textarea>
<button onClick={majorClassDependenciesGraph}>Major Class Dependency Graph</button>



def generate_major_graph(major_id, courses, course_columns, relations, relations_columns):
    coid_i = course_columns.index("course_id")
    unique_course_ids = {course[coid_i] for course in courses}

    g = graphviz.Digraph(f'Major_{major_id}')

    # Check for different verbosity levels
    # HTML template for the node
    html_template = """<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">{rows}</TABLE>>"""

    for course in courses:
        rows_html = ""
        for column_name in course_columns:
            column_index = course_columns.index(column_name)
            column_value = course[column_index]

            if (type(column_value) == str):
                wrapped_column_value = textwrap.fill(column_value, width=70, replace_whitespace=True,
                                                     break_long_words=False, break_on_hyphens=True)
                res = [html.escape(el) for el in wrapped_column_value.splitlines()]
                wrapped_column_value_with_br = "<br/>".join(res)

                # commented out rows_html lines are for cells that show both data and names of each part of data
                # If kept without names, remove empty spaces in each cell
                rows_html += f'<TR><TD>{wrapped_column_value_with_br}</TD></TR>'
                # rows_html += f'<TR><TD>{column_name}</TD><TD>{wrapped_column_value_with_br}</TD></TR>'
            else:
                rows_html += f'<TR><TD>{column_value}</TD></TR>'
                # rows_html += f'<TR><TD>{column_name}</TD><TD>{column_value}</TD></TR>'

        g.node(f"course_{course[coid_i]}", label=html_template.format(rows=rows_html).strip().replace("\n", "\\n"),
               shape='plaintext')

    coid_id = relations_columns.index("course_id")
    r_id = relations_columns.index("relation_id")
    rtype_id = relations_columns.index("relation_type")
    greq_id = relations_columns.index("grade_requirement")
    for relation in relations:
        # if they are in the major and not some random unrelated courses
        if relation[coid_id] in unique_course_ids and relation[r_id] in unique_course_ids:
            # TODO add handling of different types of relationships (rtype_id)
            g.edge(f"course_{relation[r_id]}", f"course_{relation[coid_id]}")

    return str(g)